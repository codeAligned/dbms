// Automatically generated code.  Edit at your own risk!
// Generated by bali2jak v2002.09.03.

package mdb;

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.EnvironmentNotFoundException;
import minidb.je.ExecuteHelpers;
import minidb.je.MyDbEnv;
import minidb.je.PredicateHelpers;

import java.io.UnsupportedEncodingException;
import java.util.*;

import static minidb.je.ExecuteHelpers.READ_ONLY;

public class SelectCmd extends Select {

    final public static int ARG_LENGTH = 3 ;
    final public static int TOK_LENGTH = 3 ;

    public static int totalRowCount = 0;

    public void execute () {
        
        super.execute();

        System.out.println(getContentsOfSelectedTables());
        System.out.print(totalRowCount + " row(s) selected");
    }

    private String getContentsOfSelectedTables() {
        MyDbEnv myDbEnv = new MyDbEnv();
        Database relationDB = null;
        String contents = null;

        try {
            myDbEnv.setup(ExecuteHelpers.myDbEnvPath, READ_ONLY);
            relationDB = myDbEnv.getDB("relationDB", READ_ONLY);
            DatabaseEntry relationMetaData = new DatabaseEntry();
            AstCursor c = new AstCursor();
            Map<String, String[]> metaColumnRelation = new HashMap<String, String[]>();
            Map<String, String[]> metaColumnTypeRelation = new HashMap<String, String[]>();
            Map<String, List<String[]>> allRowsOfRelations = new HashMap<String, List<String[]>>();
            c.FirstElement(getRel_list());
            String firstRelation = c.node.toString().trim();
            Map<String, List<AstNode>> clauses = null;
            if(getWherePred() != null)
                clauses = PredicateHelpers.generateClauses(firstRelation, getWherePred().arg[0]);
            List<String> fromRelations = new ArrayList<String>();
            for (; c.MoreElement(); c.NextElement()) {
                String relationName = c.node.toString().trim();
                if(relationName.equals("ALL"))
                    return(getContentsOfAllTables());
                if(!ExecuteHelpers.isTablePresent(relationDB, relationName, relationMetaData))
                    return("\nRelation not present : " + relationName);
                fromRelations.add(relationName);
                String relationDataString = new String(relationMetaData.getData(), "UTF-8");
                List<AstNode> clausesList = clauses != null ? clauses.get(relationName) : null;
                List<String> data = ExecuteHelpers.getSelectData(relationDataString, clausesList)[0];
                PredicateHelpers.formatData(metaColumnRelation, metaColumnTypeRelation, allRowsOfRelations, data);
            }

            List<String> projWithRelationName = new ArrayList<String>();

            findProjectionList(metaColumnRelation, fromRelations, projWithRelationName);

            applyLocalPredicates(allRowsOfRelations, metaColumnRelation, metaColumnTypeRelation, clauses);

            applyJoinPredicates(allRowsOfRelations, metaColumnRelation);

            applyCrossProducts(allRowsOfRelations, metaColumnRelation);

            contents = buildString(allRowsOfRelations.values().iterator().next(),
                                    metaColumnRelation.values().iterator().next(),
                                    projWithRelationName);
        } catch(EnvironmentNotFoundException e) {
            System.err.println("Database is currently empty!!.");
            return "";
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } finally {
            if(relationDB != null) relationDB.close();
            myDbEnv.close();
        }
        return contents;
    }

    private void findProjectionList(Map<String, String[]> metaColumnRelation, List<String> fromRelations, List<String> projWithRelationName) {
        String[] projections = getProj_list().toString().split(",");
        for(String p : projections) {
            p = p.trim();
            if(p.contains(".")) {
                    projWithRelationName.add(p);
            } else if(p.contains("*")) {
                for(String relName: metaColumnRelation.keySet())
                    for(String cols: metaColumnRelation.get(relName))
                        projWithRelationName.add(cols);
            } else {
                if(fromRelations.size() > 1)
                    System.err.println(p+" is not linked with any relation in projection. Prefix table with '.'");
                projWithRelationName.add(fromRelations.get(0)+"."+p);
            }
        }
    }

    private void applyCrossProducts(Map<String, List<String[]>> allRowsOfRelations, Map<String, String[]> metaColumnRelation) {
        List<List<String[]>> rows = new ArrayList<List<String[]>>();
        List<String[]> meta = new ArrayList<String[]>();

        for(String relation: allRowsOfRelations.keySet()) {
            if(!rows.contains(allRowsOfRelations.get(relation))) {
                rows.add(allRowsOfRelations.get(relation));
                meta.add(metaColumnRelation.get(relation));
            }
        }

        allRowsOfRelations.clear();
        metaColumnRelation.clear();

        while(rows.size() != 1) {
            List<String[]> r1 = rows.remove(0); String[] m1 = meta.remove(0);
            List<String[]> r2 = rows.remove(0); String[] m2 = meta.remove(0);

            String[] m3 = new String[m1.length + m2.length];
            List<String[]> r3 = new ArrayList<String[]>();
            System.arraycopy(m1, 0, m3, 0, m1.length);
            System.arraycopy(m2, 0, m3, m1.length, m2.length);

            meta.add(m3);
            for(String[] s1: r1) {
                for(String[] s2: r2) {
                    String[] s3 = new String[s1.length + s2.length];
                    System.arraycopy(s1, 0, s3, 0, s1.length);
                    System.arraycopy(s2, 0, s3, s1.length, s2.length);
                    r3.add(s3);
                }
            }
            rows.add(r3);
        }
        allRowsOfRelations.put("joined", rows.get(0));
        metaColumnRelation.put("joined", meta.get(0));
    }

    private void applyLocalPredicates(Map<String, List<String[]>> allRowsOfRelations,
                                      Map<String, String[]> metaColumnRelation,
                                      Map<String, String[]> metaColumnTypeRelation,
                                      Map<String, List<AstNode>> clauses) {
        if(getWherePred() == null) return;
        if(clauses.isEmpty()) return;
        for(String relation: clauses.keySet()) {
            int[] indices = PredicateHelpers.setIndices(metaColumnRelation, clauses, relation);
            List<String[]> filteredRows = new ArrayList<String[]>();
            for(String[] row: allRowsOfRelations.get(relation)) {
                boolean keepRow = PredicateHelpers.applyLocalPredicate(metaColumnTypeRelation.get(relation),
                        clauses, relation, indices, row);
                if(keepRow) filteredRows.add(row);
            }
            allRowsOfRelations.put(relation, filteredRows);
        }
    }

    private String buildString(List<String[]> allRowsOfRelations,
                               String[] metaColumnRelation,
                               List<String> projWithRelationName) {
        int[] indices = new int[projWithRelationName.size()];
        StringBuffer contents = new StringBuffer();
        for(int i = 0; i < projWithRelationName.size(); i++) {
            indices[i] = -1;
            for(int j = 0; j < metaColumnRelation.length; j++) {
                if(projWithRelationName.get(i).equals(metaColumnRelation[j])) {
                    indices[i] = j;
                    break;
                }
            }
            if(indices[i] != -1) contents.append(projWithRelationName.get(i)+"\t");
        }
        contents.append("\n------------------------\n");
        for(String[] row: allRowsOfRelations) {
            for(int j = 0; j < indices.length; j++) {
                try {
                    if(indices[j] != -1)
                        contents.append(row[indices[j]].replace("&&",",")+"\t");
                } catch(ArrayIndexOutOfBoundsException e) {
                    contents.append("null\t");
                }
            }
            contents.append("\n");
        }
        totalRowCount = allRowsOfRelations.size();
        return contents.toString();
    }

    private void applyJoinPredicates(Map<String, List<String[]>> allRowsOfRelations,
                                     Map<String, String[]> metaColumnRelation) {
        if(getWherePred() == null) return;
        class Join {
            AstNode lhs; AstNode rhs;
            Join(AstNode lhs, AstNode rhs) {
                this.lhs = lhs;
                this.rhs = rhs;
            }
        }
        AstCursor c = new AstCursor();
        Map<String, List<Join>> clauses = new HashMap<String, List<Join>>();
        for (c.FirstElement(getWherePred().arg[0]); c.MoreElement(); c.NextElement() ) {
            AstNode node = c.node;
            if(node instanceof JoinClause) {
                //local predicate
                if(clauses.get(node.arg[0].arg[0].toString().trim()) != null) {
                    List<Join> join_clauses = clauses.get(node.arg[0].arg[0].toString().trim());
                    join_clauses.add(new Join(node.arg[0], node.arg[1]));
                    clauses.put(node.arg[0].arg[0].toString().trim(), join_clauses);
                } else if(clauses.get(node.arg[1].arg[0].toString().trim()) != null) {
                    List<Join> join_clauses = clauses.get(node.arg[1].arg[0].toString().trim());
                    join_clauses.add(new Join(node.arg[1], node.arg[0]));
                    clauses.put(node.arg[1].arg[0].toString().trim(), join_clauses);
                } else {
                    List<Join> join_clauses = new ArrayList<Join>();
                    join_clauses.add(new Join(node.arg[0], node.arg[1]));
                    clauses.put(node.arg[0].arg[0].toString().trim(), join_clauses);
                }
            }
        }
        if(clauses.isEmpty()) return;
        List<String> centerNodes = new ArrayList<String>(clauses.keySet());
        while(!centerNodes.isEmpty()) {
            String centerNode = centerNodes.remove(0);
            for(Join j: clauses.get(centerNode)) {
                String[] center_columns = (metaColumnRelation.get(centerNode));
                List centerTableColumns = Arrays.asList(center_columns);
//                List centerTableColumnTypes = Arrays.asList(metaColumnTypeRelation.get(centerNode));
                String centerTableColumnArrays[] = null;
//                String centerTableColumnTypeArrays[] = null;
                int index_left, index_right;
                index_left = centerTableColumns.indexOf(j.lhs.toString());
                String rhs_node = j.rhs.arg[0].toString();
                index_right = Arrays.asList(metaColumnRelation.get(rhs_node)).indexOf(j.rhs.toString());
                List<String[]> joinedTable = new ArrayList<String[]>();
                boolean internal = false;
                if (centerTableColumns.contains(j.rhs.toString())) {
                    //relations are already joined ... just filter.
                    centerTableColumnArrays = center_columns;
                    internal = true;
                } else {
                    //create new list joining columns.
                    centerTableColumnArrays = new String[center_columns.length + metaColumnRelation.get(rhs_node).length];
                    System.arraycopy(center_columns, 0, centerTableColumnArrays, 0, center_columns.length);
                    System.arraycopy(metaColumnRelation.get(rhs_node), 0, centerTableColumnArrays, center_columns.length, metaColumnRelation.get(rhs_node).length);
                }
                for (String[] row : allRowsOfRelations.get(centerNode)) {
                    String lhs_value = row[index_left];
                    if(internal) {
                        if(lhs_value.equals(row[index_right]))
                            joinedTable.add(row);
                        continue;
                    }
                    for(String[] row_rhs : allRowsOfRelations.get(rhs_node)) {
                        if(lhs_value.equals(row_rhs[index_right])) {
                            String[] combine = new String[row.length + row_rhs.length];
                            System.arraycopy(row, 0, combine, 0, row.length);
                            System.arraycopy(row_rhs, 0, combine, row.length, row_rhs.length);
                            joinedTable.add(combine);
                        }
                    }
                }
                for(String r: allRowsOfRelations.keySet())
                    if(allRowsOfRelations.get(r) == allRowsOfRelations.get(centerNode))
                        allRowsOfRelations.put(r, joinedTable);
                for(String r: allRowsOfRelations.keySet())
                    if(allRowsOfRelations.get(r) == allRowsOfRelations.get(rhs_node))
                        allRowsOfRelations.put(r, joinedTable);
                for(String r: metaColumnRelation.keySet())
                    if(metaColumnRelation.get(r) == metaColumnRelation.get(centerNode))
                        metaColumnRelation.put(r, centerTableColumnArrays);
                for(String r: metaColumnRelation.keySet())
                    if(metaColumnRelation.get(r) == metaColumnRelation.get(rhs_node))
                        metaColumnRelation.put(r, centerTableColumnArrays);
            }
        }
    }

    private String getContentsOfAllTables()
            throws DatabaseException {
        ArrayList<String> relations = ExecuteHelpers.getAllRowsOfTable("relationDB")[0];
        StringBuffer displayString = new StringBuffer();
        for(int i = 0; i < relations.size(); i++) {
            String relationName = relations.get(i);
            //skip index tables
            if(relationName.contains(".")) continue;
            //get rows from each relationName
            List<String> rows = ExecuteHelpers.getSelectData(relationName)[0];
            String columns = rows.remove(0);
            displayString.append(columns.replaceFirst(",","\n(").replace(",","\t")+")\n");
            for(String s: rows)
                displayString.append(s.replace(",", "\t").replace("&&",",")+"\n");
            displayString.append("\n-----------------------\n");
        }
        return displayString.toString();
    }

    public AstToken getFROM () {
        
        return (AstToken) tok [1] ;
    }

    public Proj_list getProj_list () {
        
        return (Proj_list) arg [0] ;
    }

    public Rel_list getRel_list () {
        
        return (Rel_list) arg [1] ;
    }

    public AstToken getSELECT () {
        
        return (AstToken) tok [0] ;
    }

    public AstToken getSEMI () {
        
        return (AstToken) tok [2] ;
    }

    public WherePred getWherePred () {
        
        AstNode node = arg[2].arg [0] ;
        return (node != null) ? (WherePred) node : null ;
    }

    public boolean[] printorder () {
        
        return new boolean[] {true, false, true, false, false, true} ;
    }

    public SelectCmd setParms
    (AstToken tok0, Proj_list arg0, AstToken tok1, Rel_list arg1, AstOptNode arg2, AstToken tok2)
    {
        
        arg = new AstNode [ARG_LENGTH] ;
        tok = new AstTokenInterface [TOK_LENGTH] ;
        
        tok [0] = tok0 ;            /* SELECT */
        arg [0] = arg0 ;            /* Proj_list */
        tok [1] = tok1 ;            /* FROM */
        arg [1] = arg1 ;            /* Rel_list */
        arg [2] = arg2 ;            /* [WherePred] */
        tok [2] = tok2 ;            /* SEMI */
        
        InitChildren () ;
        return (SelectCmd) this ;
    }

}
